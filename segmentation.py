# -*- coding: utf-8 -*-
"""segmentation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1T4dikXYED4iBYX90WQJKUZgqHmk-GCrq
"""

from google.colab import drive
drive.mount('/content/drive')

#pip install scikit-image

import cv2
import numpy as np
import math
from skimage import img_as_ubyte
from skimage import io
from skimage.color import rgb2gray
from google.colab.patches import cv2_imshow

img = io.imread('/content/drive/My Drive/car15.png')
print(img.shape)
#img=cv2.resize
#cv2_imshow(img)

hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)
hue, saturation, value = cv2.split(hsv)
cv2_imshow(value)

kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5,5))
topHat = cv2.morphologyEx(value, cv2.MORPH_TOPHAT, kernel)
blackHat = cv2.morphologyEx(value, cv2.MORPH_BLACKHAT, kernel)

cv2_imshow(topHat)
cv2_imshow(blackHat)

add = cv2.add(value, topHat)
subtract = cv2.subtract(add, blackHat)

cv2_imshow(subtract)
cv2_imshow(add)

blur = cv2.GaussianBlur(subtract, (3,3), 0)

cv2_imshow(blur)

thresh = cv2.adaptiveThreshold(blur, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 19, 9)
cv2_imshow(thresh)

import math
import cv2


class ifChar:
    # this function contains some operations used by various function in the code
    def __init__(self, cntr):
        self.contour = cntr

        self.boundingRect = cv2.boundingRect(self.contour)

        [x, y, w, h] = self.boundingRect

        self.boundingRectX = x
        self.boundingRectY = y
        self.boundingRectWidth = w
        self.boundingRectHeight = h

        self.boundingRectArea = self.boundingRectWidth * self.boundingRectHeight

        self.centerX = (self.boundingRectX + self.boundingRectX + self.boundingRectWidth) / 2
        self.centerY = (self.boundingRectY + self.boundingRectY + self.boundingRectHeight) / 2

        self.diagonalSize = math.sqrt((self.boundingRectWidth ** 2) + (self.boundingRectHeight ** 2))

        self.aspectRatio = float(self.boundingRectWidth) / float(self.boundingRectHeight)


class PossiblePlate:

    def __init__(self):
        self.Plate = None
        self.Grayscale = None
        self.Thresh = None

        self.rrLocationOfPlateInScene = None

        self.strChars = ""


# this function is a 'first pass' that does a rough check on a contour to see if it could be a char
def checkIfChar(possibleChar):
    if (possibleChar.boundingRectArea > 80 and possibleChar.boundingRectWidth > 2
            and possibleChar.boundingRectHeight > 8 and 0.25 < possibleChar.aspectRatio < 1.0):

        return True
    else:
        return False


# check the center distance between characters
def distanceBetweenChars(firstChar, secondChar):
    x = abs(firstChar.centerX - secondChar.centerX)
    y = abs(firstChar.centerY - secondChar.centerY)

    return math.sqrt((x ** 2) + (y ** 2))


# use basic trigonometry (SOH CAH TOA) to calculate angle between chars
def angleBetweenChars(firstChar, secondChar):
    adjacent = float(abs(firstChar.centerX - secondChar.centerX))
    opposite = float(abs(firstChar.centerY - secondChar.centerY))

    # check to make sure we do not divide by zero if the center X positions are equal
    # float division by zero will cause a crash in Python
    if adjacent != 0.0:
        angleInRad = math.atan(opposite / adjacent)
    else:
        angleInRad = 1.5708

    # calculate angle in degrees
    angleInDeg = angleInRad * (180.0 / math.pi)

    return angleInDeg

cv2MajorVersion = cv2.__version__.split(".")[0]

if int(cv2MajorVersion) >= 4:
    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)
else:
    imageContours, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

height, width = thresh.shape

imageContours = np.zeros((height, width, 3), dtype=np.uint8)

possibleChars = []
countOfPossibleChars = 0

for i in range(0, len(contours)):

    # draw contours based on actual found contours of thresh image
    cv2.drawContours(imageContours, contours, i, (255, 255, 255))

    # retrieve a possible char by the result ifChar class give us
    possibleChar = ifChar(contours[i])

    # by computing some values (area, width, height, aspect ratio) possibleChars list is being populated
    if checkIfChar(possibleChar) is True:
        countOfPossibleChars = countOfPossibleChars + 1
        possibleChars.append(possibleChar)

cv2_imshow( imageContours)

imageContours = np.zeros((height, width, 3), np.uint8)

ctrs = []

for char in possibleChars:
    ctrs.append(char.contour)

cv2.drawContours(imageContours, ctrs, -1, (255, 255, 255))

cv2_imshow(imageContours)

kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (9,3))
dilated = cv2.dilate(imageContours, kernel, iterations=4)
cv2_imshow(dilated)

grayscale = cv2.cvtColor(dilated, cv2.COLOR_BGR2GRAY)
cv2_imshow(grayscale)
thresh1 = cv2.adaptiveThreshold(grayscale, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY_INV, 19, 9)
cnts,_ = cv2.findContours(thresh1, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
#cnts = cnts[0] if len(cnts) == 2 else cnts[1]

ROI_number = 0
for c in cnts:
    area = cv2.contourArea(c)
    if (area > 1000) and (area < 100000):
        x,y,w,h = cv2.boundingRect(c)
        #cv2.rectangle(img, (x, y), (x + w, y + h), (36,255,12), 3)
        ROI = img[y:y+h, x:x+w]
        #cv2_imshow(ROI)
        io.imsave('/content/drive/My Drive/ROI/ROI_{}.png'.format(ROI_number), ROI)
        ROI_number += 1

#cv2.imshow('thresh', thresh)
#cv2_imshow(dilated)
#cv2_imshow(img)